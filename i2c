library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

entity i2c_adau1761 is
    Port (
        -- System signals
        clk         : in  STD_LOGIC;  -- System clock (higher frequency)
        reset       : in  STD_LOGIC;  
        
        -- Control signals
        start       : in  STD_LOGIC;  -- Start transmission
        
        -- Status signals
        busy        : out STD_LOGIC;  -- Transmission in progress
        done        : out STD_LOGIC;  -- Transmission complete
        ack_error   : out STD_LOGIC;  -- ACK not received
        
        -- I2C bus signals
        scl         : out STD_LOGIC;  -- I2C clock (400kHz)
        sda         : inout STD_LOGIC; -- I2C data
        sda_out_i2c     : out std_logic ;
        sda_en_i2c      : out std_logic 
        
    );
end i2c_adau1761;

architecture khungtruyen_1 of i2c_adau1761 is
    
    -- Constants
    constant ADAU1761_ADDR : STD_LOGIC_VECTOR(7 downto 0) := "01110110";  -- 8-bit address
    constant addr_R0       : STD_LOGIC_VECTOR(15 downto 0) := x"4000";
    constant addr_R1       : STD_LOGIC_VECTOR(15 downto 0) := x"4002";
    
    --
    constant addr_R16       : STD_LOGIC_VECTOR(15 downto 0) := x"4016";
    constant addr_R64       : STD_LOGIC_VECTOR(15 downto 0) := x"40F8";
    constant addr_R15       : STD_LOGIC_VECTOR(15 downto 0) := x"4015";
    constant addr_R17       : STD_LOGIC_VECTOR(15 downto 0) := x"4017";
    constant addr_R57       : STD_LOGIC_VECTOR(15 downto 0) := x"40EB";
    --
    
    constant data_R0       : STD_LOGIC_VECTOR(7 downto 0) := "00001111";
    constant data_R1       : STD_LOGIC_VECTOR(47 downto 0) := "000000100111000100000010001111000010000100000011";
    --    
    constant data_R16       : STD_LOGIC_VECTOR(7 downto 0) := "01000000";
    constant data_R64       : STD_LOGIC_VECTOR(7 downto 0) := "00000110";
    constant data_R15       : STD_LOGIC_VECTOR(7 downto 0) := "01010001";
    constant data_R17       : STD_LOGIC_VECTOR(7 downto 0) := "00000110";
    constant data_R57       : STD_LOGIC_VECTOR(7 downto 0) := "00000000";
    --
    
    -- Clock divider for 400kHz SCL (assuming system clock is much higher)
    constant CLOCK_DIVIDE : integer := 250; -- Adjust based on your system clock frequency
    constant STOP_DELAY_CYCLES : integer := 150; -- ~0.6us delay for stop condition
    -- FSM States
    type state_type is (
        IDLE,
        -- First transaction (R0 register)
        START_COND_R0,
        ADAU_addr,
        WAIT_ACK_CHIP_R0,
        SEND_REG_ADDR_H_R0,
        WAIT_ACK_REG_H_R0,
        SEND_REG_ADDR_L_R0,
        WAIT_ACK_REG_L_R0,
        SEND_DATA_R0,
        WAIT_ACK_DATA_R0,
        STOP_COND_R0,
        
        -- Second transaction (R1 register)
        START_COND_R1,
        SEND_CHIP_ADDR_R1,
        WAIT_ACK_CHIP_R1,
        SEND_REG_ADDR_H_R1,
        WAIT_ACK_REG_H_R1,
        SEND_REG_ADDR_L_R1,
        WAIT_ACK_REG_L_R1,
        SEND_DATA_R1,
        WAIT_ACK_DATA_R1,
        STOP_COND_R1,
        
       
        DONE_STATE
    );
    
    signal state_reg        : state_type;
    signal state_next       : state_type;
    signal bit_count_reg    : unsigned(7 downto 0);
    signal bit_count_next   : unsigned(7 downto 0);
    signal byte_count_reg   : unsigned(7 downto 0);
    signal byte_count_next  : unsigned(7 downto 0);
    signal tx_data_reg      : STD_LOGIC_VECTOR(7 downto 0);
    signal tx_data_next     : STD_LOGIC_VECTOR(7 downto 0);
    signal ack_error_int    : STD_LOGIC := '0';
    signal ack_error_next   : STD_LOGIC;

    -- SCL generation: dùng integer để so sánh trực tiếp
    signal scl_count_reg    :  unsigned(7 downto 0);
    signal scl_count_next   :  unsigned(7 downto 0);
    signal scl_reg          : STD_LOGIC := '1';
    signal scl_next         : STD_LOGIC := '1';

    -- delay
    signal delay_counter_reg    : unsigned(7 downto 0);
    signal delay_counter_next : unsigned(7 downto 0);
    signal stop: std_logic;

    -- done
    signal busy_reg         : STD_LOGIC;
    signal busy_next        : STD_LOGIC;
    signal done_reg         : STD_LOGIC;
    signal done_next        : STD_LOGIC;

    -- SDA control
    signal sda_reg, sda_next          : STD_LOGIC ;
    signal sda_oen_reg, sda_oen_next  : STD_LOGIC ; -- 0 = drive, 1 = tri-state (release)
begin

    -- map internal tri-state to external inout SDA
    -- I2C: only drive '0'; never drive '1' (let pull-up handle it)
    -- sda <= '0' when (sda_oen_reg = '0' and sda_reg = '0') else 'Z';
    -- optional outputs for observation/debug
    sda <= sda_reg;
    sda_out_i2c <= sda_reg;
    sda_en_i2c  <= sda_oen_reg;

    scl <= scl_reg;

    -- State register process (sequential)
    process(clk, reset)
    begin
        if reset = '0' then  -- active-low reset as in your code
            state_reg <= IDLE;
            bit_count_reg <= (others => '0');
            scl_count_reg <= (others => '0');
            byte_count_reg <= (others => '0');
            tx_data_reg <= (others => '0');
            ack_error_int <= '0';
            busy_reg <= '0';
            done_reg <= '0';
            sda_reg <= '1';
            sda_oen_reg <= '1'; -- release by default
            delay_counter_reg <= (others => '0');
        elsif rising_edge(clk) then
            state_reg <= state_next;
            bit_count_reg <= bit_count_next;
            scl_count_reg <= scl_count_next;
            scl_reg  <= scl_next;
            byte_count_reg <= byte_count_next;
            tx_data_reg <= tx_data_next;
            busy_reg <= busy_next;
            sda_reg <= sda_next;
            sda_oen_reg <= sda_oen_next;  -- **fix here**
            done_reg <= done_next;
            ack_error_int <= ack_error_next;
            delay_counter_reg <= delay_counter_next;
        end if;
    end process;

    -- Main FSM combinational
    process(state_reg, scl_count_reg, bit_count_reg, byte_count_reg, tx_data_reg, start, sda, busy_reg, done_reg, ack_error_int, delay_counter_reg, stop, sda_reg)
    begin
        -- defaults
        state_next <= state_reg;
        scl_count_next <= scl_count_reg;
        bit_count_next <= bit_count_reg;
        scl_next <= scl_reg;
        byte_count_next <= byte_count_reg;
        tx_data_next <= tx_data_reg;
        busy_next <= busy_reg;
        done_next <= done_reg;
        ack_error_next <= ack_error_int;
        sda_next <= sda_reg;
        sda_oen_next <= sda_oen_reg;
        delay_counter_next <= delay_counter_reg;

        case state_reg is
            when IDLE =>
                busy_next <= '0';
                done_next <= '0';
                ack_error_next <= '0';
                bit_count_next <= (others => '0');
                byte_count_next <= (others => '0');
                delay_counter_next <= (others => '0');
                sda_next <= '1';
                sda_oen_next <= '1'; -- release SDA in idle
                if start = '1' then
                    busy_next <= '1';
                    state_next <= START_COND_R0;
                end if;

            when START_COND_R0 =>
                -- Make start: SDA low while SCL high
                sda_next <= '0';
                sda_oen_next <= '0';  -- drive SDA low
                tx_data_next <= ADAU1761_ADDR;
                bit_count_next <= to_unsigned(7, bit_count_next'length);
                -- ensure SCL is high for start (we keep scl_reg as '1' or enforce)
                scl_next <= '1';
                if delay_counter_reg = STOP_DELAY_CYCLES - 1 then
                           -- sda_oen_next <= '1'; -- release SDA -> goes high via pull-up
                            state_next <= ADAU_addr;
                            delay_counter_next <= (others => '0');
                        else
                            delay_counter_next <= delay_counter_reg + 1;
                        end if;
               
                

            when ADAU_addr =>
                -- increment scl counter
                scl_count_next <= scl_count_reg + 1;

                -- set defaults during transfer: drive SDA (sda_oen=0)
                sda_oen_next <= '0';

                case scl_count_reg is
                    when "00000000" =>  -- setup data (SCL low)
                        scl_next <= '0';
                        sda_next <= tx_data_reg(7); -- present MSB
                    when "01111101" =>  -- rising edge of SCL
                        scl_next <= '1';
                   when "11111001" =>  -- falling edge : shift data
                        scl_next <= '0';
                        tx_data_next <= tx_data_reg(6 downto 0) & '0';
                        if bit_count_reg = 0 then
                            state_next <= WAIT_ACK_CHIP_R0;
                            -- release SDA later in WAIT_ACK state
                        else
                            bit_count_next <= bit_count_reg - 1;
                        end if;
                        scl_count_next <= (others => '0');
                    when others =>
                        null;
                end case;

            when WAIT_ACK_CHIP_R0 =>
                scl_count_next <= scl_count_reg + 1;
                -- during ACK we must release SDA (tri-state) so slave can pull it low
                case scl_count_reg is
                    when "00000000" =>  -- setup (SCL low): release SDA
                        scl_next <= '0';
                        sda_oen_next <= '1'; -- release SDA (Z)
                        sda_next <= 'Z';      -- don't drive 1, but keep internal value
                    when "01111101" =>  -- rising edge: sample SDA
                        scl_next <= '1';
                        -- sample ack at rising edge
                        if sda = '1' then
                            ack_error_next <= '1'; -- no ACK
                        else
                            ack_error_next <= ack_error_int; -- keep
                        end if;
                     when "11111001" =>  -- falling edge: prepare next byte
                        scl_next <= '0';
                        tx_data_next <= addr_R0(15 downto 8);
                        bit_count_next <= to_unsigned(7, bit_count_next'length);
                        sda_oen_next <= '0'; -- prepare to drive next byte
                        state_next <= SEND_REG_ADDR_H_R0;
                        scl_count_next <= (others => '0');
                    when others =>
                        null;
                end case;

            -- Example STOP state (kept minimal)
            when STOP_COND_R1 =>
                scl_count_next <= scl_count_reg + 1;
                case scl_count_reg is
                    when "00000000" =>
                        scl_next <= '0';
                        sda_oen_next <= '0';
                        sda_next <= '0';
                        stop <= '1';
                    when "01111101" =>
                        scl_next <= '1';
                    when "11111001" =>
                        scl_next <= '0';
                        -- generate final stop: release SDA while SCL high (we do a short delay)
                        if delay_counter_reg = STOP_DELAY_CYCLES - 1 then
                            sda_oen_next <= '1'; -- release SDA -> goes high via pull-up
                            state_next <= DONE_STATE;
                            delay_counter_next <= (others => '0');
                        else
                            delay_counter_next <= delay_counter_reg + 1;
                        end if;
                    when others =>
                        null;
                end case;

            when DONE_STATE =>
                done_next <= '1';
                busy_next <= '0';
                state_next <= IDLE;

            when others =>
                state_next <= IDLE;
        end case;
    end process;

    -- outputs
    busy <= busy_reg;
    done <= done_reg;
    ack_error <= ack_error_int;

end khungtruyen_1;

